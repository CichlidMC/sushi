package fish.cichlidmc.sushi.api.requirement;

import fish.cichlidmc.sushi.api.registry.Id;
import fish.cichlidmc.sushi.api.requirement.interpreter.RequirementInterpreters;
import fish.cichlidmc.sushi.api.requirement.interpreter.exception.RequirementInterpretationException;
import fish.cichlidmc.sushi.impl.requirement.RequirementsImpl;
import fish.cichlidmc.tinycodecs.api.codec.Codec;
import fish.cichlidmc.tinycodecs.api.codec.CompositeCodec;
import fish.cichlidmc.tinycodecs.api.codec.dual.DualCodec;
import org.jetbrains.annotations.Contract;

import java.util.Collection;
import java.util.List;

/// A report generated by Sushi when a class is transformed, indicating all
/// external requirements which must be met for the transformed code to function.
public sealed interface Requirements extends Iterable<Requirements.Owned> permits RequirementsImpl {
	Requirements EMPTY = RequirementsImpl.EMPTY;
	Codec<Requirements> CODEC = RequirementsImpl.CODEC;

	boolean isEmpty();

	/// Create a new set of requirements containing all of these requirements as well as all given requirements.
	@Contract(value = "_->new", pure = true)
	Requirements and(Requirements requirements);

	/// Check this set of requirements using the given set of interpreters.
	/// @return a list of [Problem]s, empty if all requirements are met
	List<Problem> check(RequirementInterpreters interpreters);

	static Requirements of(Collection<Owned> owned) {
		return new RequirementsImpl(List.copyOf(owned));
	}

	static Requirements of(Owned... owned) {
		return of(List.of(owned));
	}

	/// A set of requirements that belong to a specific transformer.
	/// @param owner the ID of the transformer that produced this set of requirements
	record Owned(Id owner, List<Requirement> requirements) {
		public static final DualCodec<Owned> CODEC = CompositeCodec.of(
				Id.CODEC.fieldOf("transformer"), Owned::owner,
				Requirement.CODEC.listOf().fieldOf("requirements"), Owned::requirements,
				Owned::new
		);
	}

	/// A problem that occurred while checking requirements.
	/// @param owner the transformer that produced the relevant requirements
	/// @param requirements the chain of requirements, where the final one was unmet
	record Problem(Id owner, List<Requirement> requirements, RequirementInterpretationException exception) {
	}
}
